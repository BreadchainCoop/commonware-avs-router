name: Integration Test

on:
  push:
    branches: [ dev ]
  pull_request:
    branches: [ dev, 21-release-001 ]

env:
  CARGO_TERM_COLOR: always

jobs:
  integration-test:
    runs-on: ubuntu-latest
    timeout-minutes: 45
    environment: PRIVATE_KEY

    services:
      docker:
        image: docker:20.10.17
        options: --privileged

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 1
        submodules: recursive

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true

    - name: Cache Rust dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          ~/.cache/sccache
          target
          commonware-avs-node/target
          scripts/target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}

    - name: Install required system packages
      run: |
        sudo apt-get update
        sudo apt-get install -y jq curl sccache

    - name: Configure Rust to use sccache
      run: echo "RUSTC_WRAPPER=$(which sccache)" >> $GITHUB_ENV

    - name: Build all Rust crates (release)
      run: |
        cargo build --release
        cargo build --release --manifest-path commonware-avs-node/Cargo.toml
        cargo build --release --manifest-path scripts/Cargo.toml

    - name: Set up environment files
      env:
        PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
      run: |
        # Copy example env files
        cp example.env .env
        cp commonware-avs-node/example.env commonware-avs-node/.env
        
        # Update main .env file for local mode
        sed -i 's|^HTTP_RPC=.*|HTTP_RPC=http://localhost:8545|' .env
        sed -i 's|^WS_RPC=.*|WS_RPC=ws://localhost:8545|' .env
        sed -i "s|^PRIVATE_KEY=.*|PRIVATE_KEY=$PRIVATE_KEY|" .env
        
        # Update commonware-avs-node .env file for local mode
        sed -i 's|^HTTP_RPC=.*|HTTP_RPC=http://localhost:8545|' commonware-avs-node/.env
        sed -i 's|^WS_RPC=.*|WS_RPC=ws://localhost:8545|' commonware-avs-node/.env
        sed -i 's|^AVS_DEPLOYMENT_PATH=.*|AVS_DEPLOYMENT_PATH="../eigenlayer-bls-local/.nodes/avs_deploy.json"|' commonware-avs-node/.env
        sed -i "s|^PRIVATE_KEY=.*|PRIVATE_KEY=$PRIVATE_KEY|" commonware-avs-node/.env

    - name: Start local blockchain environment
      env:
        PRIVATE_KEY: ${{ secrets.PRIVATE_KEY }}
      run: |
        cd eigenlayer-bls-local
        
        # Copy and configure eigenlayer-bls-local .env properly
        cp example.env .env
        
        # Set required environment variables for LOCAL mode
        sed -i 's|^ENVIRONMENT=.*|ENVIRONMENT=LOCAL|' .env
        sed -i 's|^RPC_URL=.*|RPC_URL=http://ethereum:8545|' .env
        sed -i 's|^FORK_URL=.*|FORK_URL=https://ethereum-holesky.publicnode.com|' .env
        
        # Uncomment Holesky contract addresses for LOCAL mode
        sed -i 's|^#DELEGATION_MANAGER_ADDRESS=0xA44151489861Fe9e3055d95adC98FbD462B948e7|DELEGATION_MANAGER_ADDRESS=0xA44151489861Fe9e3055d95adC98FbD462B948e7|' .env
        sed -i 's|^#STRATEGY_MANAGER_ADDRESS=0xdfB5f6CE42aAA7830E94ECFCcAd411beF4d4D5b6|STRATEGY_MANAGER_ADDRESS=0xdfB5f6CE42aAA7830E94ECFCcAd411beF4d4D5b6|' .env
        sed -i 's|^#LST_CONTRACT_ADDRESS=0x3F1c547b21f65e10480dE3ad8E19fAAC46C95034|LST_CONTRACT_ADDRESS=0x3F1c547b21f65e10480dE3ad8E19fAAC46C95034|' .env
        sed -i 's|^#LST_STRATEGY_ADDRESS=0x7D704507b76571a51d9caE8AdDAbBFd0ba0e63d3|LST_STRATEGY_ADDRESS=0x7D704507b76571a51d9caE8AdDAbBFd0ba0e63d3|' .env
        sed -i 's|^#BLS_SIGNATURE_CHECKER_ADDRESS=0xca249215e082e17c12bb3c4881839a3f883e5c6b|BLS_SIGNATURE_CHECKER_ADDRESS=0xca249215e082e17c12bb3c4881839a3f883e5c6b|' .env
        sed -i 's|^#OPERATOR_STATE_RETRIEVER_ADDRESS=0xB4baAfee917fb4449f5ec64804217bccE9f46C67|OPERATOR_STATE_RETRIEVER_ADDRESS=0xB4baAfee917fb4449f5ec64804217bccE9f46C67|' .env
        sed -i 's|^#ALLOCATION_MANAGER_ADDRESS=0x78469728304326CBc65f8f95FA756B0B73164462|ALLOCATION_MANAGER_ADDRESS=0x78469728304326CBc65f8f95FA756B0B73164462|' .env
        
        # Ensure required service configuration variables are set
        if ! grep -q "^CERBERUS_GRPC_PORT=" .env; then
            echo "CERBERUS_GRPC_PORT=50051" >> .env
        else
            sed -i 's|^CERBERUS_GRPC_PORT=.*|CERBERUS_GRPC_PORT=50051|' .env
        fi
        
        if ! grep -q "^CERBERUS_METRICS_PORT=" .env; then
            echo "CERBERUS_METRICS_PORT=9081" >> .env
        else
            sed -i 's|^CERBERUS_METRICS_PORT=.*|CERBERUS_METRICS_PORT=9081|' .env
        fi
        
        if ! grep -q "^SIGNER_ENDPOINT=" .env; then
            echo "SIGNER_ENDPOINT=http://signer:50051" >> .env
        else
            sed -i 's|^SIGNER_ENDPOINT=.*|SIGNER_ENDPOINT=http://signer:50051|' .env
        fi
        
        if ! grep -q "^TEST_ACCOUNTS=" .env; then
            echo "TEST_ACCOUNTS=3" >> .env
        else
            sed -i 's|^TEST_ACCOUNTS=.*|TEST_ACCOUNTS=3|' .env
        fi
        
        # Set the private key and funded key for eigenlayer-bls-local
        sed -i "s|^PRIVATE_KEY=.*|PRIVATE_KEY=$PRIVATE_KEY|" .env
        sed -i "s|^FUNDED_KEY=.*|FUNDED_KEY=$PRIVATE_KEY|" .env
        
        echo "Final eigenlayer-bls-local .env configuration:"
        cat .env
        
        # Start the Docker containers
        echo "Starting Docker containers..."
        docker compose up -d
        
        # Wait for ethereum service to be ready
        echo "Waiting for ethereum service to be ready..."
        sleep 10
        
        # Wait for the eigenlayer service to complete its setup
        echo "Waiting for eigenlayer setup to complete..."
        timeout=600
        elapsed=0
        while [ $elapsed -lt $timeout ]; do
          # Check if deployment has completed by looking for completion message in logs
          if docker compose logs eigenlayer 2>/dev/null | grep -q "Script execution finished. Keeping container open..." && [ -f .nodes/avs_deploy.json ] && [ -s .nodes/avs_deploy.json ]; then
            echo "EigenLayer setup has completed successfully"
            break
          fi
          
          # Check for any error indicators
          error_check=$(docker compose logs eigenlayer 2>/dev/null | grep -i "error\|failed" | tail -1 || echo "")
          if [ -n "$error_check" ]; then
            echo "Detected potential error: $error_check"
          fi
          
          echo "Waiting for eigenlayer setup to complete... ($elapsed/$timeout seconds)"
          sleep 15
          elapsed=$((elapsed + 15))
        done
        
        if [ $elapsed -ge $timeout ]; then
          echo "Timeout waiting for eigenlayer setup to complete"
          echo "Checking container logs..."
          docker compose logs eigenlayer
          exit 1
        fi
        
        # Wait a bit more for file system writes to complete
        sleep 10
        
        # Verify deployment file was created
        if [ ! -f .nodes/avs_deploy.json ]; then
          echo "Deployment file .nodes/avs_deploy.json was not created"
          echo "Checking eigenlayer logs:"
          docker compose logs eigenlayer
          echo "Checking ethereum logs:"
          docker compose logs ethereum
          exit 1
        fi
        
        echo "Deployment file created successfully"
        cat .nodes/avs_deploy.json

    - name: Start contributors
      run: |
        cd commonware-avs-node
        
        # Create logs directory
        mkdir -p ../logs
        
        # Start contributor 1 in background
        source .env
        cargo run --release -- --key-file $CONTRIBUTOR_1_KEYFILE --port 3001 --orchestrator orchestrator.json > ../logs/contributor1.log 2>&1 &
        echo $! > contributor1.pid
        echo "Contributor 1 started with PID: $!"
        
        # Wait a bit before starting next contributor
        sleep 1
        
        # Start contributor 2 in background
        cargo run --release -- --key-file $CONTRIBUTOR_2_KEYFILE --port 3002 --orchestrator orchestrator.json > ../logs/contributor2.log 2>&1 &
        echo $! > contributor2.pid
        echo "Contributor 2 started with PID: $!"
        
        # Wait a bit before starting next contributor
        sleep 1
        
        # Start contributor 3 in background
        cargo run --release -- --key-file $CONTRIBUTOR_3_KEYFILE --port 3003 --orchestrator orchestrator.json > ../logs/contributor3.log 2>&1 &
        echo $! > contributor3.pid
        echo "Contributor 3 started with PID: $!"
        
        # Wait for contributors to initialize
        echo "Waiting for contributors to initialize..."
        sleep 15

    - name: Start orchestrator
      run: |
        source .env
        
        # Start orchestrator in background
        cargo run --release -- --key-file commonware-avs-node/orchestrator.json --port 3000 > logs/orchestrator.log 2>&1 &
        echo $! > orchestrator.pid
        echo "Orchestrator started with PID: $!"
        
        # Wait for orchestrator to initialize
        echo "Waiting for orchestrator to initialize..."
        sleep 15

    - name: Wait for increment operations and verify
      run: |
        # Wait for at least 2 aggregation cycles (30 seconds each + buffer)
        echo "Waiting for signature aggregation cycles to complete..."
        echo "This will take approximately 2-3 minutes..."
        
        # Build and run verification script
        cd scripts
        cargo build --release --bin verify_increments
        source ../.env
        
        # Set the deployment path relative to the scripts directory
        export AVS_DEPLOYMENT_PATH="../eigenlayer-bls-local/.nodes/avs_deploy.json"
        echo "AVS_DEPLOYMENT_PATH set to: $AVS_DEPLOYMENT_PATH"
        echo "File exists check:"
        ls -la "$AVS_DEPLOYMENT_PATH" || echo "File not found at $AVS_DEPLOYMENT_PATH"
        
        cargo run --release --bin verify_increments

    - name: Collect logs on failure
      if: failure()
      run: |
        echo "=== Recent orchestrator logs ==="
        tail -n 20 logs/orchestrator.log || echo "No orchestrator logs found"
        
        echo "=== Recent contributor logs ==="
        tail -n 10 logs/contributor1.log || echo "No contributor1 logs found"
        tail -n 10 logs/contributor2.log || echo "No contributor2 logs found"
        tail -n 10 logs/contributor3.log || echo "No contributor3 logs found"
        
        echo "=== Recent eigenlayer setup logs ==="
        cd eigenlayer-bls-local
        docker compose logs --tail=50 eigenlayer || echo "No eigenlayer logs found"

    - name: Cleanup processes
      if: always()
      run: |
        echo "Cleaning up processes..."
        
        # Kill all background processes
        if [ -f orchestrator.pid ]; then
          pid=$(cat orchestrator.pid)
          if kill -0 "$pid" 2>/dev/null; then
            echo "Killing orchestrator (PID: $pid)"
            kill "$pid" || true
          fi
        fi
        
        if [ -f commonware-avs-node/contributor1.pid ]; then
          pid=$(cat commonware-avs-node/contributor1.pid)
          if kill -0 "$pid" 2>/dev/null; then
            echo "Killing contributor1 (PID: $pid)"
            kill "$pid" || true
          fi
        fi
        
        if [ -f commonware-avs-node/contributor2.pid ]; then
          pid=$(cat commonware-avs-node/contributor2.pid)
          if kill -0 "$pid" 2>/dev/null; then
            echo "Killing contributor2 (PID: $pid)"
            kill "$pid" || true
          fi
        fi
        
        if [ -f commonware-avs-node/contributor3.pid ]; then
          pid=$(cat commonware-avs-node/contributor3.pid)
          if kill -0 "$pid" 2>/dev/null; then
            echo "Killing contributor3 (PID: $pid)"
            kill "$pid" || true
          fi
        fi
        
        # Stop Docker containers
        echo "Stopping Docker containers..."
        cd eigenlayer-bls-local
        docker compose down || true
        
        echo "Cleanup completed" 
