name: Docker Compose Test

on:
  push:
    branches:
      - main
      - dev
  pull_request:
    branches:
      - main
      - dev

jobs:
  docker-compose-test:
    name: Test with Docker Compose
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create .env file from example
        run: |
          cp example.env .env
          
          # Set to LOCAL mode
          sed -i 's|^ENVIRONMENT=.*|ENVIRONMENT=LOCAL|' .env
          
          # Uncomment and set local RPC URLs
          sed -i 's|^# HTTP_RPC=http://localhost:8545|HTTP_RPC=http://localhost:8545|' .env
          sed -i 's|^# WS_RPC=ws://localhost:8545|WS_RPC=ws://localhost:8545|' .env
          sed -i 's|^# RPC_URL=http://ethereum:8545|RPC_URL=http://ethereum:8545|' .env
          
          # Set FORK_URL for local forking from Holesky  
          sed -i 's|^# FORK_URL=.*|FORK_URL=https://ethereum-holesky.publicnode.com|' .env
          
          # Uncomment Holesky testnet contract addresses (needed for LOCAL mode with fork)
          sed -i 's|^#DELEGATION_MANAGER_ADDRESS=0xA44151489861Fe9e3055d95adC98FbD462B948e7|DELEGATION_MANAGER_ADDRESS=0xA44151489861Fe9e3055d95adC98FbD462B948e7|' .env
          sed -i 's|^#STRATEGY_MANAGER_ADDRESS=0xdfB5f6CE42aAA7830E94ECFCcAd411beF4d4D5b6|STRATEGY_MANAGER_ADDRESS=0xdfB5f6CE42aAA7830E94ECFCcAd411beF4d4D5b6|' .env
          sed -i 's|^#LST_CONTRACT_ADDRESS=0x3F1c547b21f65e10480dE3ad8E19fAAC46C95034|LST_CONTRACT_ADDRESS=0x3F1c547b21f65e10480dE3ad8E19fAAC46C95034|' .env
          sed -i 's|^#LST_STRATEGY_ADDRESS=0x7D704507b76571a51d9caE8AdDAbBFd0ba0e63d3|LST_STRATEGY_ADDRESS=0x7D704507b76571a51d9caE8AdDAbBFd0ba0e63d3|' .env
          sed -i 's|^#BLS_SIGNATURE_CHECKER_ADDRESS=0xca249215e082e17c12bb3c4881839a3f883e5c6b|BLS_SIGNATURE_CHECKER_ADDRESS=0xca249215e082e17c12bb3c4881839a3f883e5c6b|' .env
          sed -i 's|^#OPERATOR_STATE_RETRIEVER_ADDRESS=0xB4baAfee917fb4449f5ec64804217bccE9f46C67|OPERATOR_STATE_RETRIEVER_ADDRESS=0xB4baAfee917fb4449f5ec64804217bccE9f46C67|' .env
          sed -i 's|^#ALLOCATION_MANAGER_ADDRESS=0x78469728304326CBc65f8f95FA756B0B73164462|ALLOCATION_MANAGER_ADDRESS=0x78469728304326CBc65f8f95FA756B0B73164462|' .env
          
          # Use default Anvil private key for testing
          DEFAULT_ANVIL_KEY="0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"
          sed -i "s|^PRIVATE_KEY=.*|PRIVATE_KEY=$DEFAULT_ANVIL_KEY|" .env
          sed -i "s|^FUNDED_KEY=.*|FUNDED_KEY=$DEFAULT_ANVIL_KEY|" .env

      - name: Build router image locally
        run: |
          docker build -t commonware-avs-router:debug-v2 .
          
      - name: Pull required images
        run: |
          docker compose pull ethereum eigenlayer signer node-1 node-2 node-3

      - name: Prepare for EigenLayer setup
        run: |
          # Create the .nodes directory for EigenLayer to populate
          mkdir -p .nodes
          echo "EigenLayer will generate BLS keys and deploy contracts..."

      - name: Start services with docker-compose
        run: |
          docker compose up -d
          
      - name: Wait for EigenLayer setup to complete
        run: |
          echo "Waiting for EigenLayer to complete setup..."
          timeout=300
          elapsed=0
          
          while [ $elapsed -lt $timeout ]; do
            # Check if the keys have been generated by EigenLayer
            if [ -f ".nodes/operator_keys/testacc1.private.bls.key.json" ] && 
               [ -f ".nodes/operator_keys/testacc2.private.bls.key.json" ] && 
               [ -f ".nodes/operator_keys/testacc3.private.bls.key.json" ]; then
              echo "✓ BLS keys generated by EigenLayer"
              
              # Check if AVS deployment file exists
              if [ -f ".nodes/avs_deploy.json" ]; then
                echo "✓ AVS deployed"
                echo "=== EigenLayer setup complete ==="
                ls -la .nodes/
                ls -la .nodes/operator_keys/
                break
              fi
            fi
            
            # Check if container exited with error
            container_id=$(docker compose ps -q eigenlayer)
            if [ -n "$container_id" ] && [ "$(docker inspect -f '{{.State.Status}}' $container_id 2>/dev/null)" = "exited" ]; then
              exit_code=$(docker inspect -f '{{.State.ExitCode}}' $container_id)
              if [ "$exit_code" != "0" ]; then
                echo "EigenLayer container exited with error code: $exit_code"
                docker compose logs eigenlayer --tail=50
                exit 1
              fi
            fi
            
            echo "Waiting for EigenLayer setup... ($elapsed/$timeout seconds)"
            sleep 10
            elapsed=$((elapsed + 10))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "Timeout waiting for EigenLayer setup"
            docker compose logs eigenlayer --tail=50
            exit 1
          fi
          
          # Check if nodes and router are still running
          for service in node-1 node-2 node-3 router; do
            if [ "$(docker compose ps $service --format json | jq -r ".[0].State")" != "running" ]; then
              echo "Service $service is not running!"
              docker compose logs $service --tail 50
              exit 1
            fi
          done

      - name: Run health checks
        run: |
          # Check Ethereum RPC
          curl -X POST http://localhost:8545 \
            -H "Content-Type: application/json" \
            -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
            || (echo "Ethereum RPC not responding" && exit 1)
          
          # Check router HTTP endpoint
          curl -f http://localhost:4000/health || echo "Note: Router may not have a health endpoint"
          
          # Check if services are communicating (via logs)
          echo "=== Router logs ==="
          docker compose logs router --tail 20
          
          echo "=== Node-1 logs ==="
          docker compose logs node-1 --tail 20

      - name: Verify services are running
        run: |
          # Check if all critical services are running
          echo "Checking service status..."
          docker compose ps
          
          for service in node-1 node-2 node-3 router; do
            if [ "$(docker compose ps $service --format json | jq -r ".[0].State")" != "running" ]; then
              echo "Service $service is not running!"
              docker compose logs $service --tail 50
              exit 1
            fi
          done
          
          echo "✓ All services are running"

      - name: Test counter increment functionality
        run: |
          echo "Testing counter increment..."
          
          # Wait for services to be fully ready
          sleep 20
          
          # Check initial counter state in router logs
          echo "=== Checking counter state in logs ==="
          
          # Look for counter increment messages
          INITIAL_COUNT=$(docker compose logs router | grep -o "state=\"[0-9]*\"" | tail -1 | grep -o "[0-9]*" || echo "0")
          echo "Initial counter state: $INITIAL_COUNT"
          
          # Wait for the next aggregation cycle (usually 30 seconds)
          echo "Waiting for aggregation cycle..."
          sleep 35
          
          # Check if counter has incremented
          FINAL_COUNT=$(docker compose logs router | grep -o "state=\"[0-9]*\"" | tail -1 | grep -o "[0-9]*" || echo "0")
          echo "Final counter state: $FINAL_COUNT"
          
          # Verify increment
          if [ "$FINAL_COUNT" -gt "$INITIAL_COUNT" ]; then
            echo "✓ Counter successfully incremented from $INITIAL_COUNT to $FINAL_COUNT"
          else
            echo "✗ Counter did not increment (still at $FINAL_COUNT)"
            echo "=== Recent router logs ==="
            docker compose logs router --tail 50
            exit 1
          fi
          
          # Check for successful signature aggregation
          if docker compose logs router | grep -q "Successfully aggregated signatures"; then
            echo "✓ Signatures are being successfully aggregated"
          else
            echo "⚠ No signature aggregation detected yet"
          fi
          
          # Verify nodes are participating
          for node in node-1 node-2 node-3; do
            if docker compose logs $node | grep -q "Signed message"; then
              echo "✓ $node is signing messages"
            else
              echo "⚠ $node signature not detected"
            fi
          done

      - name: Collect logs on failure
        if: failure()
        run: |
          echo "=== Docker Compose Status ==="
          docker compose ps -a
          
          echo "=== Ethereum Logs ==="
          docker compose logs ethereum --tail 50
          
          echo "=== EigenLayer Logs ==="
          docker compose logs eigenlayer --tail 100
          
          echo "=== Router Logs ==="
          docker compose logs router --tail 100
          
          echo "=== Node-1 Logs ==="
          docker compose logs node-1 --tail 100
          
          echo "=== Node-2 Logs ==="
          docker compose logs node-2 --tail 100
          
          echo "=== Node-3 Logs ==="
          docker compose logs node-3 --tail 100

      - name: Cleanup
        if: always()
        run: |
          docker compose down --volumes --remove-orphans